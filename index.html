<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Collision-map-maker</title>
</head>

<body>
    <div id = "control_buttons" 
        style = "position: fixed; right: 0; top: 20px; z-index: 1000; display: flex; flex-direction: column; border: 2px solid red;"
        >
        <label for="front_map">Upload front map</label>
        <input type="file" onchange='loadImage(event, initStage)' id = "front_map" name = "front_map"/>
    
        <label for="opacity_range">Opacity:</label>
        <input type="range" min="0" max="100" value="1" onchange="changeBackOpacity(event)" step="10"
            name = 'opacity_range' id = 'opacity_range' style = "max-width: 150px;"
        >
        <label for="brush_width">Brush width:</label>
        <input type="range" min="0" max="200" value="1" onchange="changeBrushWidth(event)" step="10"
            name = 'brush_width' id = 'brush_width' style = "max-width: 150px;"
        >
        <button id = 'download_btn'>Download</button>
    </div>

    <div id = 'advanced_controls'
        style = "position: fixed; right: 0; bottom: 20px; z-index: 1000; 
        display: flex; flex-direction: column; border: 2px solid red; display: none;"
    >
        <p>Advanced: </p>
        <label for="back_map">Upload collision map</label>
        <input type="file" onchange='loadImage(event, changeBack)' id = "back_map" name = "back_map"/>

        <button onclick = "generateCollisionMap()">Auto generate</button>
    </div>

    <div id="container" style = "border: 2px solid red; position: relative">

    </div>
    
</body>
    <script src="https://unpkg.com/konva@8/konva.min.js"></script>
    <script>
        let stage = null, layer = null, front = null, back = {canvas: null, ctx: null, image: null}
        let isPaint = false, mode = 'brush'
        let opacity_range = document.getElementById('opacity_range'), brush_width = document.getElementById('brush_width')
        let advanced = document.getElementById('advanced_controls')

        function loadImage (e, cb) {
            const input = e.target
            if (!input.files.length) return

            const reader = new FileReader()

            reader.onload = () => cb(reader.result)
            reader.readAsDataURL(input.files[0])
        }

        function changeBack (dataURL) {
            const image = new Image()
            image.onload = () => {
                if (image.width !== back.canvas.width || image.height !== back.canvas.height) {
                    alert('Wrong collision map size')
                    return
                }
                back.ctx.drawImage(image, 0, 0)
            }
            image.src = dataURL
        }

        function initStage (dataURL) {
            stage = new Konva.Stage({
                container: 'container',
                width: window.innerWidth,
                height: window.innerHeight,
            })
        
            layer = new Konva.Layer()
            stage.add(layer)

            setFrontImage(dataURL)
        }

        function setFrontImage (dataURL) {
            const image = new Image()
            image.onload = () => {
                front = new Konva.Image({ image })
                layer.add(front)

                stage.setAttrs({width: image.width, height: image.height})
                setBackImage()
            }
            image.src = dataURL
        }

        function setBackImage () {
            back.canvas = document.createElement('canvas')
            back.canvas.width = stage.width()
            back.canvas.height = stage.height()
            back.canvas.style.position = 'absolute'
            back.canvas.style.top = '0px'
            back.canvas.style.zIndex = -1
            document.getElementById('container').appendChild(back.canvas)

            back.ctx = back.canvas.getContext("2d")
            back.ctx.fillStyle = "white"
            back.ctx.fillRect(0, 0, back.canvas.width, back.canvas.height)
            back.ctx.strokeStyle = '#000000'
            back.ctx.lineJoin = 'round'
            back.ctx.lineWidth = 10
            
            opacity_range.value = 50

            stage.setAttr('opacity', opacity_range.value / 100)

            back.image = new Konva.Image({ image: back.canvas, opacity: 0 })
            layer.add(back.image)

            drawing()

            advanced.style.display = 'flex'
        }

        function changeBackOpacity (e) {
            if (stage) stage.setAttr('opacity', opacity_range.value / 100)
        }
        function changeBrushWidth (e) {
            if (back.ctx) back.ctx.lineWidth = e.target.value
        }

        function drawing () {

            let lastPointerPosition = null

            back.image.on('mousedown touchstart', function () {
                isPaint = true
                lastPointerPosition = stage.getPointerPosition()
            })

            stage.on('mouseup touchend', function () {
                isPaint = false
            })

            stage.on('mousemove touchmove', function () {
                if (!isPaint) return

                if (mode === 'brush') back.ctx.globalCompositeOperation = 'source-over'
                if (mode === 'eraser') back.ctx.globalCompositeOperation = 'destination-out'

                back.ctx.beginPath()

                let localPos = {
                    x: lastPointerPosition.x - back.image.x(),
                    y: lastPointerPosition.y - back.image.y(),
                }
                back.ctx.moveTo(localPos.x, localPos.y)
                let pos = stage.getPointerPosition()
                localPos = {
                    x: pos.x - back.image.x(),
                    y: pos.y - back.image.y(),
                }
                back.ctx.lineTo(localPos.x, localPos.y)
                back.ctx.closePath()
                back.ctx.stroke()

                lastPointerPosition = pos
            })
        }

        async function generateCollisionMap () {
            stage.setAttr('opacity', 1)
            
            const canvas = front.toCanvas()
            const ctx = canvas.getContext('2d')
            const sec_canvas = front.toCanvas()
            const sec_ctx = sec_canvas.getContext('2d')

            stage.setAttr('opacity', opacity_range.value / 100)

            ctx.fillStyle = "white"
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            ctx.fillStyle = '#000000'

            function drawPixel(x, y) {
                const data = sec_ctx.getImageData(x, y, 1, 1).data
                if (!data[0] && !data[1] && !data[2]) ctx.fillRect(x, y, 1, 1);
            }

            var t1 = new Date()

            function process_draw () {
                return new Promise(res => {
                    for (let x = 0; x < canvas.width; x++) for (let y = 0; y < canvas.height; y++) drawPixel(x, y)
                    res()
                })
            }

            await process_draw()

            var t2 = new Date()
            var dt = t2 - t1

            console.log('elapsed time = ' + dt / 1000 + ' s')

            back.ctx.drawImage(canvas, 0, 0)
            
        }
        
        function downloadURI(uri, name) {
            const link = document.createElement('a')
            link.download = name
            link.href = uri
            document.body.appendChild(link)
            link.click()
            document.body.removeChild(link)
            delete link
        }

        document.getElementById('download_btn').addEventListener('click', () => {
            if (!back.canvas) return
            const dataURL = back.canvas.toDataURL()
            downloadURI(dataURL, 'collision_map.png')
        })

      </script>
</html>